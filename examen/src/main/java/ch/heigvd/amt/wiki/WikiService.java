package ch.heigvd.amt.wiki;

import ch.heigvd.amt.wiki.dtos.MediaWikiRecentChange;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.smallrye.mutiny.infrastructure.Infrastructure;
import io.smallrye.mutiny.subscription.Cancellable;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;
import jakarta.inject.Inject;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.jboss.logging.Logger;
import org.jboss.resteasy.reactive.client.SseEvent;

import java.util.Optional;

@ApplicationScoped
public class WikiService {

    @RestClient
    WikiClient wikiClient;

    @Inject
    ObjectMapper objectMapper;

    Cancellable cancellable;

    /** Number of events processed since last start of service **/
    long nbProcessed = 0;

    /** Number of events processed in the previous run **/
    long lastNbProcessed = 0;

    @Inject
    Logger log;

    @Inject
    Event<WikiEvent> wikiEvents;

    public void stop() {
        log.info("Stopping WikiService");
        Optional.ofNullable(cancellable).ifPresent(Cancellable::cancel);
        lastNbProcessed = nbProcessed;
        nbProcessed = 0;
        cancellable = null;
    }

    public boolean isRunning() {
        return cancellable != null;
    }

    /**
     * @return The numbers of events processed since the last start. Reset to 0 whenever processing is stopped.
     */
    public long getNbProcessed() {
        return nbProcessed;
    }

    public long getLastNbProcessed() {
        return lastNbProcessed;
    }

    public void start() {
        log.info("Starting WikiService");
        var events = wikiClient.get();
        cancellable = events
                .onFailure().invoke(this::handleFailure)
                .emitOn(Infrastructure.getDefaultWorkerPool())
                .subscribe().with(this::handleEvent,
                        this::handleFailure);
    }

    private void handleFailure(Throwable throwable) {
        log.warn("Error during Wiki SSE GET request: ", throwable);
        stop();
    }

    private void handleEvent(SseEvent<String> sseEvent) {
        nbProcessed++;
        if ("ok".equals(sseEvent.comment())) return;
        var eventData = sseEvent.data();
        try {
            var event = objectMapper.readValue(eventData, MediaWikiRecentChange.class);
            callProcessors(event);
            fireEvent(event);
        } catch (JsonProcessingException e) {
            log.warn("Error during JSON deserialization, event will be ignored: ", e);
        }
    }

    private void fireEvent(MediaWikiRecentChange change) {
        wikiEvents.fireAsync(new WikiEvent(String.valueOf(change.id()), change.type(), change.title(), change.notify_url()));
    }

    /**
     * TODO
     * Call all processor synchronously in a loop.
     * By default if a processor triggers an Exception, it is caught and logged but the WikiService continues.
     *
     * Behavior of {@link ch.heigvd.amt.wiki.HaltProcessing} is implement by using Java reflection.
     * Hint: Instance injected using Jakarta CDI will be of a class generated by the CDI implementation and not directly
     * the class within code. (getSuperClass() might be needed).
     * @param change the wikimedia change
     */
    private void callProcessors(MediaWikiRecentChange change) {
       // TODO
    }
}
